// Code generated by mocker; DO NOT EDIT
// github.com/travisjeffery/mocker
package mock

import (
	"io"
	"sync"
)

var (
	lockCommitLogAppend       sync.RWMutex
	lockCommitLogDelete       sync.RWMutex
	lockCommitLogNewReader    sync.RWMutex
	lockCommitLogNewestOffset sync.RWMutex
	lockCommitLogOldestOffset sync.RWMutex
	lockCommitLogTruncate     sync.RWMutex
)

// CommitLog is a mock implementation of CommitLog.
//
//     func TestSomethingThatUsesCommitLog(t *testing.T) {
//
//         // make and configure a mocked CommitLog
//         mockedCommitLog := &CommitLog{
//             AppendFunc: func(in1 []byte) (int64, error) {
// 	               panic("TODO: mock out the Append method")
//             },
//             DeleteFunc: func() error {
// 	               panic("TODO: mock out the Delete method")
//             },
//             NewReaderFunc: func(offset int64,maxBytes int32) (io.Reader, error) {
// 	               panic("TODO: mock out the NewReader method")
//             },
//             NewestOffsetFunc: func() int64 {
// 	               panic("TODO: mock out the NewestOffset method")
//             },
//             OldestOffsetFunc: func() int64 {
// 	               panic("TODO: mock out the OldestOffset method")
//             },
//             TruncateFunc: func(in1 int64) error {
// 	               panic("TODO: mock out the Truncate method")
//             },
//         }
//
//         // TODO: use mockedCommitLog in code that requires CommitLog
//         //       and then make assertions.
//
//     }
type CommitLog struct {
	// AppendFunc mocks the Append method.
	AppendFunc func(in1 []byte) (int64, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func() error

	// NewReaderFunc mocks the NewReader method.
	NewReaderFunc func(offset int64, maxBytes int32) (io.Reader, error)

	// NewestOffsetFunc mocks the NewestOffset method.
	NewestOffsetFunc func() int64

	// OldestOffsetFunc mocks the OldestOffset method.
	OldestOffsetFunc func() int64

	// TruncateFunc mocks the Truncate method.
	TruncateFunc func(in1 int64) error

	// calls tracks calls to the methods.
	calls struct {
		// Append holds details about calls to the Append method.
		Append []struct {
			// In1 is the in1 argument value.
			In1 []byte
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
		}
		// NewReader holds details about calls to the NewReader method.
		NewReader []struct {
			// Offset is the offset argument value.
			Offset int64
			// MaxBytes is the maxBytes argument value.
			MaxBytes int32
		}
		// NewestOffset holds details about calls to the NewestOffset method.
		NewestOffset []struct {
		}
		// OldestOffset holds details about calls to the OldestOffset method.
		OldestOffset []struct {
		}
		// Truncate holds details about calls to the Truncate method.
		Truncate []struct {
			// In1 is the in1 argument value.
			In1 int64
		}
	}
}

// Reset resets the calls made to the mocked APIs.
func (mock *CommitLog) Reset() {
	lockCommitLogAppend.Lock()
	mock.calls.Append = nil
	lockCommitLogAppend.Unlock()
	lockCommitLogDelete.Lock()
	mock.calls.Delete = nil
	lockCommitLogDelete.Unlock()
	lockCommitLogNewReader.Lock()
	mock.calls.NewReader = nil
	lockCommitLogNewReader.Unlock()
	lockCommitLogNewestOffset.Lock()
	mock.calls.NewestOffset = nil
	lockCommitLogNewestOffset.Unlock()
	lockCommitLogOldestOffset.Lock()
	mock.calls.OldestOffset = nil
	lockCommitLogOldestOffset.Unlock()
	lockCommitLogTruncate.Lock()
	mock.calls.Truncate = nil
	lockCommitLogTruncate.Unlock()
}

// Append calls AppendFunc.
func (mock *CommitLog) Append(in1 []byte) (int64, error) {
	if mock.AppendFunc == nil {
		panic("moq: CommitLog.AppendFunc is nil but CommitLog.Append was just called")
	}
	callInfo := struct {
		In1 []byte
	}{
		In1: in1,
	}
	lockCommitLogAppend.Lock()
	mock.calls.Append = append(mock.calls.Append, callInfo)
	lockCommitLogAppend.Unlock()
	return mock.AppendFunc(in1)
}

// AppendCalled returns true if at least one call was made to Append.
func (mock *CommitLog) AppendCalled() bool {
	lockCommitLogAppend.RLock()
	defer lockCommitLogAppend.RUnlock()
	return len(mock.calls.Append) > 0
}

// AppendCalls gets all the calls that were made to Append.
// Check the length with:
//     len(mockedCommitLog.AppendCalls())
func (mock *CommitLog) AppendCalls() []struct {
	In1 []byte
} {
	var calls []struct {
		In1 []byte
	}
	lockCommitLogAppend.RLock()
	calls = mock.calls.Append
	lockCommitLogAppend.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *CommitLog) Delete() error {
	if mock.DeleteFunc == nil {
		panic("moq: CommitLog.DeleteFunc is nil but CommitLog.Delete was just called")
	}
	callInfo := struct {
	}{}
	lockCommitLogDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	lockCommitLogDelete.Unlock()
	return mock.DeleteFunc()
}

// DeleteCalled returns true if at least one call was made to Delete.
func (mock *CommitLog) DeleteCalled() bool {
	lockCommitLogDelete.RLock()
	defer lockCommitLogDelete.RUnlock()
	return len(mock.calls.Delete) > 0
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedCommitLog.DeleteCalls())
func (mock *CommitLog) DeleteCalls() []struct {
} {
	var calls []struct {
	}
	lockCommitLogDelete.RLock()
	calls = mock.calls.Delete
	lockCommitLogDelete.RUnlock()
	return calls
}

// NewReader calls NewReaderFunc.
func (mock *CommitLog) NewReader(offset int64, maxBytes int32) (io.Reader, error) {
	if mock.NewReaderFunc == nil {
		panic("moq: CommitLog.NewReaderFunc is nil but CommitLog.NewReader was just called")
	}
	callInfo := struct {
		Offset   int64
		MaxBytes int32
	}{
		Offset:   offset,
		MaxBytes: maxBytes,
	}
	lockCommitLogNewReader.Lock()
	mock.calls.NewReader = append(mock.calls.NewReader, callInfo)
	lockCommitLogNewReader.Unlock()
	return mock.NewReaderFunc(offset, maxBytes)
}

// NewReaderCalled returns true if at least one call was made to NewReader.
func (mock *CommitLog) NewReaderCalled() bool {
	lockCommitLogNewReader.RLock()
	defer lockCommitLogNewReader.RUnlock()
	return len(mock.calls.NewReader) > 0
}

// NewReaderCalls gets all the calls that were made to NewReader.
// Check the length with:
//     len(mockedCommitLog.NewReaderCalls())
func (mock *CommitLog) NewReaderCalls() []struct {
	Offset   int64
	MaxBytes int32
} {
	var calls []struct {
		Offset   int64
		MaxBytes int32
	}
	lockCommitLogNewReader.RLock()
	calls = mock.calls.NewReader
	lockCommitLogNewReader.RUnlock()
	return calls
}

// NewestOffset calls NewestOffsetFunc.
func (mock *CommitLog) NewestOffset() int64 {
	if mock.NewestOffsetFunc == nil {
		panic("moq: CommitLog.NewestOffsetFunc is nil but CommitLog.NewestOffset was just called")
	}
	callInfo := struct {
	}{}
	lockCommitLogNewestOffset.Lock()
	mock.calls.NewestOffset = append(mock.calls.NewestOffset, callInfo)
	lockCommitLogNewestOffset.Unlock()
	return mock.NewestOffsetFunc()
}

// NewestOffsetCalled returns true if at least one call was made to NewestOffset.
func (mock *CommitLog) NewestOffsetCalled() bool {
	lockCommitLogNewestOffset.RLock()
	defer lockCommitLogNewestOffset.RUnlock()
	return len(mock.calls.NewestOffset) > 0
}

// NewestOffsetCalls gets all the calls that were made to NewestOffset.
// Check the length with:
//     len(mockedCommitLog.NewestOffsetCalls())
func (mock *CommitLog) NewestOffsetCalls() []struct {
} {
	var calls []struct {
	}
	lockCommitLogNewestOffset.RLock()
	calls = mock.calls.NewestOffset
	lockCommitLogNewestOffset.RUnlock()
	return calls
}

// OldestOffset calls OldestOffsetFunc.
func (mock *CommitLog) OldestOffset() int64 {
	if mock.OldestOffsetFunc == nil {
		panic("moq: CommitLog.OldestOffsetFunc is nil but CommitLog.OldestOffset was just called")
	}
	callInfo := struct {
	}{}
	lockCommitLogOldestOffset.Lock()
	mock.calls.OldestOffset = append(mock.calls.OldestOffset, callInfo)
	lockCommitLogOldestOffset.Unlock()
	return mock.OldestOffsetFunc()
}

// OldestOffsetCalled returns true if at least one call was made to OldestOffset.
func (mock *CommitLog) OldestOffsetCalled() bool {
	lockCommitLogOldestOffset.RLock()
	defer lockCommitLogOldestOffset.RUnlock()
	return len(mock.calls.OldestOffset) > 0
}

// OldestOffsetCalls gets all the calls that were made to OldestOffset.
// Check the length with:
//     len(mockedCommitLog.OldestOffsetCalls())
func (mock *CommitLog) OldestOffsetCalls() []struct {
} {
	var calls []struct {
	}
	lockCommitLogOldestOffset.RLock()
	calls = mock.calls.OldestOffset
	lockCommitLogOldestOffset.RUnlock()
	return calls
}

// Truncate calls TruncateFunc.
func (mock *CommitLog) Truncate(in1 int64) error {
	if mock.TruncateFunc == nil {
		panic("moq: CommitLog.TruncateFunc is nil but CommitLog.Truncate was just called")
	}
	callInfo := struct {
		In1 int64
	}{
		In1: in1,
	}
	lockCommitLogTruncate.Lock()
	mock.calls.Truncate = append(mock.calls.Truncate, callInfo)
	lockCommitLogTruncate.Unlock()
	return mock.TruncateFunc(in1)
}

// TruncateCalled returns true if at least one call was made to Truncate.
func (mock *CommitLog) TruncateCalled() bool {
	lockCommitLogTruncate.RLock()
	defer lockCommitLogTruncate.RUnlock()
	return len(mock.calls.Truncate) > 0
}

// TruncateCalls gets all the calls that were made to Truncate.
// Check the length with:
//     len(mockedCommitLog.TruncateCalls())
func (mock *CommitLog) TruncateCalls() []struct {
	In1 int64
} {
	var calls []struct {
		In1 int64
	}
	lockCommitLogTruncate.RLock()
	calls = mock.calls.Truncate
	lockCommitLogTruncate.RUnlock()
	return calls
}
